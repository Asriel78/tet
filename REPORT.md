# Лабораторная работа №5

| Лабораторная работа №5  | M3137          | АК   |
| ----------------------- | -------------- | ---- |
| Оптимизация по скорости | Новожилов Я.Н. | 2026 |

## Тестовое окружение

- Процессор: AMD Ryzen 5 7500F 6-Core Processor, 3701 МГц
- Ядер: 6, логических процессоров: 12
- ОС: Microsoft Windows 11 Pro
- Компилятор: g++ с флагами `-std=c++23 -O3 -fopenmp`

## Описание задачи

Реализация автоматического улучшения контрастности изображений в цветовом пространстве YCbCr.601 (PC range) с использованием OpenMP для параллелизации.

## Алгоритм

1. Построение гистограммы яркости Y для всех пикселей
2. Определение Y_min и Y_max с учётом коэффициента игнорирования
3. Линейное растяжение диапазона: `Y_new = (Y - Y_min) * 255 / (Y_max - Y_min)`
4. Преобразование обратно в RGB с насыщением

## Тестовые изображения

| Изображение | Размер файла |
|-------------|--------------|
| small.pnm   | ~1.3 MB      |
| medium.pnm  | ~6 MB        |
| large.pnm   | ~46 MB       |

## Эксперименты

### Эксперимент 1: Зависимость от числа потоков (schedule static)

Изображение: large.pnm, coef: 0.00390625

| Потоки | Время (мс) | Ускорение |
|--------|------------|-----------|
| 1      | 91         | 1.11      |
| 2      | 53         | 1.91      |
| 4      | 28         | 3.61      |
| 8      | 20         | 5.05      |
| 16     | 18         | 5.61      |

Baseline (realization 1): 101 мс

![График 1](assets/graph1_threads_time.png)

### Эксперимент 2: Зависимость от числа потоков (schedule dynamic, default chunk)

| Потоки | Время (мс) | Ускорение |
|--------|------------|-----------|
| 1      | 426        | 0.24      |
| 2      | 1080       | 0.09      |
| 4      | 1125       | 0.09      |
| 8      | 1588       | 0.06      |
| 16     | 1837       | 0.05      |

**Анализ:** Dynamic schedule без указания chunk_size показывает катастрофически плохие результаты. Причина — слишком маленький chunk_size по умолчанию (1 итерация), что приводит к огромному overhead на синхронизацию между потоками. Чем больше потоков, тем хуже — больше конкуренции за получение новых задач.

### Эксперимент 3: Влияние chunk_size (8 потоков)

| Schedule | chunk_size | Время (мс) |
|----------|------------|------------|
| static   | 1          | 21         |
| static   | 10         | 22         |
| static   | 100        | 21         |
| static   | 1000       | 20         |
| static   | 10000      | 21         |
| dynamic  | 1          | 1593       |
| dynamic  | 10         | 260        |
| dynamic  | 100        | 40         |
| dynamic  | 1000       | 17         |
| dynamic  | 10000      | 18         |

![График 3](assets/graph3_chunk_comparison.png)

**Анализ:** 
- Static практически не зависит от chunk_size — работа делится поровну заранее, overhead минимален
- Dynamic критически зависит от chunk_size: при chunk=1 время в 80 раз больше, чем при chunk=1000
- При достаточно большом chunk_size (≥1000) dynamic сравнивается со static и даже немного быстрее

### Эксперимент 4: Ручное распределение (realization 3)

| Потоки | Время (мс) | Ускорение |
|--------|------------|-----------|
| 1      | 93         | 1.09      |
| 2      | 50         | 2.02      |
| 4      | 37         | 2.73      |
| 8      | 20         | 5.05      |
| 16     | 20         | 5.05      |

**Анализ:** Ручное распределение показывает результаты, сопоставимые со static schedule. На малом числе потоков (4) немного хуже, на 8+ — идентично. Это ожидаемо, так как ручное распределение по сути повторяет логику static.

### Эксперимент 5: Сравнение всех реализаций

Изображение: large.pnm, 8 потоков, оптимальные параметры

| Реализация                    | Время (мс) | Ускорение |
|-------------------------------|------------|-----------|
| 1 (однопоточная)              | 101        | 1.00      |
| 2 (static)                    | 20         | 5.05      |
| 2 (dynamic, chunk=1000)       | 17         | 5.94      |
| 3 (manual)                    | 20         | 5.05      |

![График 5](assets/graph5_all_comparison.png)

### Ускорение

![График 2](assets/graph2_speedup.png)

**Анализ:** Максимальное ускорение ~5-6x при 8 потоках на 6-ядерном процессоре (12 логических). Это близко к теоретическому максимуму для данной задачи. Дальнейшее увеличение потоков (16) не даёт прироста — все ядра уже загружены.

## Выводы

1. **Оптимальное число потоков:** 8 (соответствует числу логических процессоров, но с учётом накладных расходов)

2. **Лучший тип планирования:** `dynamic` с `chunk_size=1000` показал лучший результат (17 мс), но `static` стабильнее и не требует подбора chunk_size

3. **Оптимальный chunk_size:** Для static не критичен. Для dynamic — не менее 1000 для данного размера изображения

4. **Сравнение auto vs manual:** Практически идентичные результаты. OpenMP эффективно распределяет работу автоматически

5. **Масштабируемость:** Ускорение ~5x на 6-ядерном процессоре. Не достигает идеального 6x из-за:
   - Последовательных участков (чтение/запись файла, подсчёт гистограммы)
   - Накладных расходов на создание/синхронизацию потоков
   - Закона Амдала

## Оптимальные параметры для сдачи

```
--realization 2
--num_threads 8  
--schedule dynamic
--chunk_size 1000
```

Или более безопасный вариант без подбора chunk_size:
```
--realization 2
--num_threads 8
--schedule static
```
